[{"categories":["linux","常用命令参数"],"content":"docker-compose 的学习笔记","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"简介： Docker-Compose项目是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。Compose允许用户通过一个单独的docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。 Docker-Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker-Compose运行目录下的所有文件（docker-compose.yml，extends文件或环境变量文件等）组成一个工程，若无特殊指定工程名即为当前目录名。一个工程当中可包含多个服务，每个服务中定义了容器运行的镜像，参数，依赖。一个服务当中可包括多个容器实例，Docker-Compose并没有解决负载均衡的问题，因此需要借助其它工具实现服务发现及负载均衡。 Docker-Compose的工程配置文件默认为docker-compose.yml，可通过环境变量COMPOSE_FILE或-f参数自定义配置文件，其定义了多个有依赖关系的服务及每个服务运行的容器。 使用一个Dockerfile模板文件，可以让用户很方便的定义一个单独的应用容器。在工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个Web项目，除了Web服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"一、常用命令 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose 常见的命令格式如下 $ docker-compose [-f \u003carg\u003e...] [options] [COMMAND] [ARGS...] 常见的选项包括 -f，–file FILE指定Compose模板文件，默认为docker-compose.yml，可以多次指定。 -p，–project-name NAME指定项目名称，默认将使用所在目录名称作为项目名。 -x-network-driver 使用Docker的可拔插网络后端特性（需要Docker 1.9+版本） -x-network-driver DRIVER指定网络后端的驱动，默认为bridge（需要Docker 1.9+版本） -verbose输出更多调试信息 -v，–version打印版本并退出 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:1","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose up $ docker-compose up [options] [--scale SERVICE=NUM...] [SERVICE...] 选项包括： -d 在后台运行服务容器 –no-color 不使用颜色来区分不同的服务的控制输出 –no-deps 不启动服务所链接的容器 –force-recreate 强制重新创建容器，不能与–no-recreate同时使用 –no-recreate 如果容器已经存在，则不重新创建，不能与–force-recreate同时使用 –no-build 不自动构建缺失的服务镜像 –build 在启动容器前构建服务镜像 –abort-on-container-exit 停止所有容器，如果任何一个容器被停止，不能与-d同时使用 -t, –timeout TIMEOUT 停止容器时候的超时（默认为10秒） –remove-orphans 删除服务中没有在compose文件中定义的容器 –scale SERVICE=NUM 设置服务运行容器的个数，将覆盖在compose中通过scale指定的参数 $ docker-compose up 启动所有服务 $ docker-compose up -d 在后台所有启动服务 -f 指定使用的Compose模板文件，默认为docker-compose.yml，可以多次指定。 $ docker-compose -f docker-compose.yml up -d ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:2","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose ps 列出项目中目前所有的容器 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:3","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose start 启动已经存在的服务容器。 $ docker-compose start [SERVICE...] $ docker-compose start ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:4","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose stop 停止正在运行的容器，可以通过docker-compose start 再次启动。 $ docker-compose stop [options] [SERVICE...] ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:5","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose restart 重启项目中的服务。 $ docker-compose restart [options] [SERVICE...] 选项包括： -t, –timeout TIMEOUT，指定重启前停止容器的超时（默认为10秒） ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:6","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose down 停止和删除容器、网络、卷、镜像。 $ docker-compose down [options] 选项包括 –rmi type，删除镜像，类型必须是：all，删除compose文件中定义的所有镜像；local，删除镜像名为空的镜像 -v, –volumes，删除已经在compose文件中定义的和匿名的附在容器上的数据卷 –remove-orphans，删除服务中没有在compose中定义的容器 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:7","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose logs 查看服务容器的输出。默认情况下，docker-compose将对不同的服务输出使用不同的颜色来区分。可以通过–no-color来关闭颜色。 $ docker-compose logs [options] [SERVICE...] ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:8","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose build 构建（重新构建）项目中的服务容器。 $ docker-compose build [options] [--build-arg key=val...] [SERVICE...] 选项包括： –compress 通过gzip压缩构建上下环境 –force-rm 删除构建过程中的临时容器 –no-cache 构建镜像过程中不使用缓存 –pull 始终尝试通过拉取操作来获取更新版本的镜像 -m, –memory MEM为构建的容器设置内存大小 –build-arg key=val为服务设置build-time变量 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:9","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose pull 拉取服务依赖的镜像。 $ docker-compose pull [options] [SERVICE...] 选项包括： –ignore-pull-failures，忽略拉取镜像过程中的错误 –parallel，多个镜像同时拉取 –quiet，拉取镜像过程中不打印进度信息 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:10","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose rm 删除所有（停止状态的）服务容器。 $ docker-compose rm [options] [SERVICE...] 选项包括： –f, –force，强制直接删除，包括非停止状态的容器 -v，删除容器所挂载的数据卷 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:11","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"docker-compose run 在指定服务上执行一个命令。 $ docker-compose run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...] ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:12","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"二、docker-compose 模版文件 Compose允许用户通过一个docker-compose.yml模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。 Compose模板文件是一个定义服务、网络和卷的YAML文件。Compose模板文件默认路径是当前目录下的docker-compose.yml，可以使用.yml或.yaml作为文件扩展名。 Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。 先来看一份 docker-compose.yml 文件： version: '2' services: web: image: dockercloud/hello-world ports: - 8080 networks: - front-tier - back-tier redis: image: redis links: - web networks: - back-tier lb: image: dockercloud/haproxy ports: - 80:80 links: - web networks: - front-tier - back-tier volumes: - /var/run/docker.sock:/var/run/docker.sock networks: front-tier: driver: bridge back-tier: driver: bridge 可以看到一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，下面先来看 services 的书写规则。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"1. image services: web: image: hello-world 在 services 标签下的第二级标签是 web，这个名字是用户自己自定义，它就是服务名称。 image 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 例如下面这些格式都是可以的： image: redis image: ubuntu:14.04 image: tutum/influxdb image: example-registry.com:4000/postgresql image: a4bc65fd ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:1","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"2. build 服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器。 build: /path/to/build/dir 也可以是相对路径，只要上下文确定就可以读取到 Dockerfile。 build: ./dir 设定上下文根目录，然后以该目录为准指定 Dockerfile。 build: context: ../ dockerfile: path/of/Dockerfile 注意 build 都是一个目录，如果你要指定 Dockerfile 文件需要在 build 标签的子级标签中使用 dockerfile 标签指定，如上面的例子。 如果你同时指定了 image 和 build 两个标签，那么 Compose 会构建镜像并且把镜像命名为 image 后面的那个名字。 build: ./dir image: webapp:tag 既然可以在 docker-compose.yml 中定义构建任务，那么一定少不了 arg 这个标签，就像 Dockerfile 中的 ARG 指令，它可以在构建过程中指定环境变量，但是在构建成功后取消，在 docker-compose.yml 文件中也支持这样的写法： build: context: . args: buildno: 1 password: secret 下面这种写法也是支持的，一般来说下面的写法更适合阅读。 build: context: . args: - buildno=1 - password=secret 与 ENV 不同的是，ARG 是允许空值的。例如： args: - buildno - password 这样构建过程可以向它们赋值。 注意：YAML 的布尔值（true, false, yes, no, on, off）必须要使用引号引起来（单引号、双引号均可），否则会当成字符串解析。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:2","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"3. command 使用 command 可以覆盖容器启动后默认执行的命令。 command: bundle exec thin -p 3000 也可以写成类似 Dockerfile 中的格式： command: [bundle, exec, thin, -p, 3000] ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:3","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"4. container_name Compose 的容器名称格式是：\u003c项目名称\u003e\u003c服务名称\u003e\u003c序号\u003e 虽然可以自定义项目名称、服务名称，但是如果你想完全控制容器的命名，可以使用这个标签指定： container_name: app 这样容器的名字就指定为 app 了。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:4","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"5. depends_on 在使用 Compose 时，最大的好处就是少打启动命令，但是一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。 例如在没启动数据库容器的时候启动了应用容器，这时候应用容器会因为找不到数据库而退出，为了避免这种情况我们需要加入一个标签，就是 depends_on，这个标签解决了容器的依赖、启动先后的问题。 例如下面容器会先启动 redis 和 db 两个服务，最后才启动 web 服务： version: '2' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意的是，默认情况下使用 docker-compose up web 这样的方式启动 web 服务时，也会启动 redis 和 db 两个服务，因为在配置文件中定义了依赖关系。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:5","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"6. dns 和 –dns 参数一样用途，格式如下： dns: 8.8.8.8 也可以是一个列表： dns: - 8.8.8.8 - 9.9.9.9 此外 dns_search 的配置也类似： dns_search: example.com dns_search: - dc1.example.com - dc2.example.com ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:6","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"7. tmpfs 挂载临时目录到容器内部，与 run 的参数一样效果： tmpfs: /run tmpfs: - /run - /tmp ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:7","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"8. entrypoint 在 Dockerfile 中有一个指令叫做 ENTRYPOINT 指令，用于指定接入点，第四章有对比过与 CMD 的区别。 在 docker-compose.yml 中可以定义接入点，覆盖 Dockerfile 中的定义： entrypoint: /code/entrypoint.sh 格式和 Docker 类似，不过还可以写成这样： entrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:8","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"9. env_file .env 文件可以设置 Compose 的变量。而在 docker-compose.yml 中可以定义一个专门存放变量的文件。 如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。 如果有变量名称与 environment 指令冲突，则以后者为准。格式如下： env_file: .env 或者根据 docker-compose.yml 设置多个： env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 注意的是这里所说的环境变量是对宿主机的 Compose 而言的，如果在配置文件中有 build 操作，这些变量并不会进入构建过程中，如果要在构建中使用变量还是首选前面刚讲的 arg 标签。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:9","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"10. environment 与上面的 env_file 标签完全不同，反而和 arg 有几分类似，这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，这是与 arg 最大的不同。 一般 arg 标签的变量仅用在构建过程中。而 environment 和 Dockerfile 中的 ENV 指令一样会把变量一直保存在镜像、容器中，类似 docker run -e 的效果。 environment: RACK_ENV: development SHOW: 'true' SESSION_SECRET: environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:10","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"11. expose 这个标签与Dockerfile中的EXPOSE指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上docker-compose.yml的端口映射还得ports这样的标签。 expose: - \"3000\" - \"8000\" ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:11","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"12. external_links 在使用Docker过程中，我们会有许多单独使用docker run启动的容器，为了使Compose能够连接这些不在docker-compose.yml中定义的容器，我们需要一个特殊的标签，就是external_links，它可以让Compose项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。 格式如下： external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:12","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"13. extra_hosts 添加主机名的标签，就是往/etc/hosts文件中添加一些记录，与Docker client的–add-host类似： extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" 启动之后查看容器内部hosts： 162.242.195.82 somehost 50.31.209.229 otherhost ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:13","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"14. labels 向容器添加元数据，和Dockerfile的LABEL指令一个意思，格式如下： labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" links 还记得上面的depends_on吧，那个标签解决的是启动顺序问题，这个标签解决的是容器连接问题，与Docker client的–link一样效果，会连接到其它服务中的容器。 格式如下： links: - db - db:database - redis 使用的别名将自动在服务容器中的/etc/hosts里创建。例如： 172.12.2.186 db 172.12.2.186 database 172.12.2.187 redis 相应的环境变量也将被创建。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:14","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"16. logging 这个标签用于配置日志服务。格式如下： logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" 默认的driver是json-file。只有json-file和journald可以通过docker-compose logs显示日志，其他方式有其他日志查看方式，但目前Compose不支持。对于可选值可以使用options指定。 有关更多这方面的信息可以阅读官方文档： https://docs.docker.com/engine/admin/logging/overview/ ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:15","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"17. pid pid: \"host\" 将PID模式设置为主机PID模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:16","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"18. ports 映射端口的标签。 使用HOST:CONTAINER格式或者只是指定容器的端口，宿主机会随机映射端口。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" 注意：当使用HOST:CONTAINER格式来映射端口时，如果你使用的容器端口小于60你可能会得到错误得结果，因为YAML将会解析xx:yy这种数字格式为60进制。所以建议采用字符串格式。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:17","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"19. security_opt 为每个容器覆盖默认的标签。简单说来就是管理全部服务的标签。比如设置全部服务的user标签值为USER。 security_opt: - label:user:USER - label:role:ROLE ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:18","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"20. stop_signal 设置另一个信号来停止容器。在默认情况下使用的是SIGTERM停止容器。设置另一个信号可以使用stop_signal标签。 stop_signal: SIGUSR1 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:19","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"21. volumes 挂载一个目录或者一个已存在的数据卷容器，可以直接使用 [HOST:CONTAINER] 这样的格式，或者使用 [HOST:CONTAINER:ro] 这样的格式，后者对于容器来说，数据卷是只读的，这样可以有效保护宿主机的文件系统。 docker-compose支持两种方式设置持久化的文件 servicename: image: image-name volumes: - /path/to/file:/path/to/container/file 这种方式将文件直接挂载到容器中，使用起来比较直观，但是需要管理本地路径。 servicename: image: image-name volumes: - volume-name:/path/to/container/file volumes: volume-name: /path/to/local/file Compose的数据卷指定路径可以是相对路径，使用 . 或者 .. 来指定相对目录。 数据卷的格式可以是下面多种形式： volumes: // 只是指定一个路径，Docker 会自动在创建一个数据卷（这个路径是容器内部的）。 - /var/lib/mysql // 使用绝对路径挂载数据卷 - /opt/data:/var/lib/mysql // 以 Compose 配置文件为中心的相对路径作为数据卷挂载到容器。 - ./cache:/tmp/cache // 使用用户的相对路径（~/ 表示的目录是 /home/\u003c用户目录\u003e/ 或者 /root/）。 - ~/configs:/etc/configs/:ro // 已经存在的命名的数据卷。 - datavolume:/var/lib/mysql 如果你不使用宿主机的路径，你可以指定一个volume_driver。 volume_driver: mydriver 使用docker volume ls命令可以查看本地挂载的文件。 使用docker volume inspect volume-name命令可以查看具体的真实地址。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:20","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"22. volumes_from 从其它容器或者服务挂载数据卷，可选的参数是 :ro或者 :rw，前者表示容器只读，后者表示容器对数据卷是可读可写的。默认情况下是可读可写的。 volumes_from: - service_name - service_name:ro - container:container_name - container:container_name:rw ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:21","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"23. cap_add, cap_drop 添加或删除容器的内核功能。 cap_add: - ALL cap_drop: - NET_ADMIN - SYS_ADMIN ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:22","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"24. cgroup_parent 指定一个容器的父级cgroup。 cgroup_parent: m-executor-abcd ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:23","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"25. devices 设备映射列表。与Docker client的–device参数类似。 devices: - \"/dev/ttyUSB0:/dev/ttyUSB0\" ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:24","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"26. extends 这个标签可以扩展另一个服务，扩展内容可以是来自在当前文件，也可以是来自其他文件，相同服务的情况下，后来者会有选择地覆盖原有配置。 extends: file: common.yml service: webapp 用户可以在任何地方使用这个标签，只要标签内容包含file和service两个值就可以了。file的值可以是相对或者绝对路径，如果不指定file的值，那么Compose会读取当前YML文件的信息。 更多的操作细节在后面的12.3.4小节有介绍。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:25","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"27. network_mode 网络模式，与Docker client的–net参数类似，只是相对多了一个service:[service name] 的格式。 例如： network_mode: \"bridge\" network_mode: \"host\" network_mode: \"none\" network_mode: \"service:[service name]\" network_mode: \"container:[container name/id]\" 可以指定使用服务或者容器的网络。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:26","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"28. networks 加入指定网络，格式如下： services: some-service: networks: - some-network - other-network 关于这个标签还有一个特别的子标签aliases，这是一个用来设置服务别名的标签，例如： services: some-service: networks: some-network: aliases: - alias1 - alias3 other-network: aliases: - alias2 相同的服务可以在不同的网络有不同的别名。 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:27","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux","常用命令参数"],"content":"29. 其它 还有这些标签：cpu_shares, cpu_quota, cpuset, domainname, hostname, ipc, mac_address, mem_limit, memswap_limit, privileged, read_only, restart, shm_size, stdin_open, tty, user, working_dir 上面这些都是一个单值的标签，类似于使用docker run的效果。 cpu_shares: 73 cpu_quota: 50000 cpuset: 0,1 user: postgresql working_dir: /code domainname: foo.com hostname: foo ipc: host mac_address: 02:42:ac:11:65:43 mem_limit: 1000000000 memswap_limit: 2000000000 privileged: true restart: always read_only: true shm_size: 64M stdin_open: true tty: true Compose目前有三个版本分别为Version 1，Version 2，Version 3，Compose区分Version 1和Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2支持更多的指令。Version 1将来会被弃用。 三、参考链接 Docker Compose 配置文件详解 ","date":"2023-02-11","objectID":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:28","tags":["docker","ubuntu","linux"],"title":"Docker-Compose常用命令","uri":"/docker-compose%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"本文为笔者在 Ubuntu 22.04 安装 docker 的参考文章，在此转载以作记录","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"1.Ubuntu 安装 docker 警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker. ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:0:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"准备工作 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:1:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"系统要求 本次安装操作系统为： Ubuntu Server 22.04 LTS 64bit Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:1:1","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"卸载旧版本 旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本： $ sudo apt-get remove docker \\ docker-engine \\ docker.io ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:1:2","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"使用 APT 安装 由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 $ sudo apt-get update $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 $ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 官方源 # $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 然后，我们需要向 sources.list 中添加 Docker 软件源 $ echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null # 官方源 # $ echo \\ # \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ # $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:2:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"安装 Docker 更新 apt 软件包缓存，并安装 docker-ce： $ sudo apt-get update $ sudo apt-get install docker-ce docker-ce-cli containerd.io ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:2:1","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"使用脚本自动安装 在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 --mirror 选项使用国内源进行安装： 若你想安装测试版的 Docker, 请从 test.docker.com 获取脚本 # $ curl -fsSL test.docker.com -o get-docker.sh $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh --mirror Aliyun # $ sudo sh get-docker.sh --mirror AzureChinaCloud 执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:3:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"启动 Docker $ sudo systemctl enable docker $ sudo systemctl start docker ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:4:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： $ sudo groupadd docker 将当前用户加入 docker 组： $ sudo usermod -aG docker ${USER} 退出当前终端并重新登录，进行如下测试。 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:5:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"测试 Docker 是否安装正确 $ docker run --rm hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world b8dfde127a29: Pull complete Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.(amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 若能正常输出以上信息，则说明安装成功。 2.镜像加速 如果在使用过程中发现拉取 Docker 镜像十分缓慢，可以配置 Docker 国内镜像加速。 国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。国内很多云服务商都提供了国内加速器服务，例如： 阿里云加速器(点击管理控制台 -\u003e 登录账号(淘宝账号) -\u003e 右侧镜像工具 -\u003e 镜像加速器 -\u003e 复制加速器地址) 网易云加速器 https://hub-mirror.c.163.com 百度云加速器 https://mirror.baidubce.com 由于镜像服务可能出现宕机，建议同时配置多个镜像。各个镜像站测试结果请到 docker-practice/docker-registry-cn-mirror-test 查看。 国内各大云服务商（腾讯云、阿里云、百度云）均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务，具体请参考本页最后一小节。 本节我们以 网易云 镜像服务 https://hub-mirror.c.163.com 为例进行介绍。 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:6:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"Ubuntu 16.04+、Debian 8+、CentOS 7+ 目前主流 Linux 发行版均已使用 systemd 进行服务管理，这里介绍如何在使用 systemd 的 Linux 发行版中配置镜像加速器。 请首先执行以下命令，查看是否在 docker.service 文件中配置过镜像地址。 $ systemctl cat docker | grep '\\-\\-registry\\-mirror' 如果该命令有输出，那么请执行 $ systemctl cat docker 查看 ExecStart= 出现的位置，修改对应的文件内容去掉 --registry-mirror 参数及其值，并按接下来的步骤进行配置。 如果以上命令没有任何输出，那么就可以在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）： { \"registry-mirrors\": \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\" ] } 注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。 之后重新启动服务。 $ sudo systemctl daemon-reload $ sudo systemctl restart docke ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:7:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"检查加速器是否生效 执行 $ docker info，如果从结果中看到了如下内容，说明配置成功。 Registry Mirrors: https://hub-mirror.c.163.com/ ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:8:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"k8s.gcr.io 镜像 可以登录 阿里云 容器镜像服务 镜像中心 -\u003e 镜像搜索 查找。 例如 k8s.gcr.io/coredns:1.6.7 镜像可以用 registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:1.6.7 代替。 一般情况下有如下对应关系： # $ docker pull k8s.gcr.io/xxx $ docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/xxx ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:9:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"不再提供服务的镜像 某些镜像不再提供服务，添加无用的镜像加速器，会拖慢镜像拉取速度，你可以从镜像配置列表中删除它们。 https://dockerhub.azk8s.cn 已转为私有 https://reg-mirror.qiniu.com https://registry.docker-cn.com 建议 watch（页面右上角） 镜像测试 这个 GitHub 仓库，会更新各个镜像地址的状态。 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:10:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"云服务商 某些云服务商提供了 仅供内部 访问的镜像服务，当您的 Docker 运行在云平台时可以选择它们。 Azure 中国镜像 https://dockerhub.azk8s.cn 腾讯云 https://mirror.ccs.tencentyun.com 3. docker-compose安装 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:11:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"Compose 简介 Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。 如果你还不了解 YML 文件配置，可以先阅读 YAML 入门教程。 ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:12:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"Compose 使用的三个步骤 使用 Dockerfile 定义应用程序的环境。 使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。 最后，执行 docker-compose up 命令来启动并运行整个应用程序。 docker-compose.yml 的配置案例如下（配置参数参考下文）： ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:13:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"实例 # yaml 配置实例 version: '3' services: web: build: . ports: - \"5000:5000\" volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:13:1","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux"],"content":"Compose 安装 Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：https://github.com/docker/compose/releases。 运行以下命令以下载 Docker Compose 的当前稳定版本： $ sudo curl -L \"https://github.com/docker/compose/releases/download/v2.2.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 要安装其他版本的 Compose，请替换 v2.2.2。 Docker Compose 存放在 GitHub，不太稳定。 你可以也通过执行下面的命令，高速安装 Docker Compose。 curl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` \u003e /usr/local/bin/docker-compose 将可执行权限应用于二进制文件： $ sudo chmod +x /usr/local/bin/docker-compose 创建软链： $ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 测试是否安装成功： $ docker-compose version cker-compose version 1.24.1, build 4667896b 注意： 对于 alpine，需要以下依赖包： py-pip，python-dev，libffi-dev，openssl-dev，gcc，libc-dev，和 make。 4. 参考链接 https://yeasy.gitbook.io/docker_practice/install/ubuntu https://yeasy.gitbook.io/docker_practice/install/mirror ","date":"2023-01-15","objectID":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/:14:0","tags":["docker","mirror","ubuntu","linux"],"title":"Ubuntu 22.04 安装docker并换源","uri":"/ubuntu-22.04-%E5%AE%89%E8%A3%85docker%E5%B9%B6%E6%8D%A2%E6%BA%90/"},{"categories":["linux","常用命令参数"],"content":"Rclone 常用命令参数","date":"2023-01-04","objectID":"/rclone-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/","tags":["Rclone","Gdrive"],"title":"Rclone 常用命令参数","uri":"/rclone-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/"},{"categories":["linux","常用命令参数"],"content":"设置 命令 说明 rclone config 添加、删除、管理网盘等操作 rclone config file 显示配置文件的路径 rclone config show 显示配置文件信息 root@SunPma:~# rclone config Current remotes: Name Type ==== ==== DB dropbox GD drive e) Edit existing remote n) New remote d) Delete remote r) Rename remote c) Copy remote s) Set configuration password q) Quit config e/n/d/r/c/s/q\u003e 语法 # 本地到网盘 rclone [功能选项] \u003c本地路径\u003e \u003c配置名称:路径\u003e [参数] [参数] # 网盘到本地 rclone [功能选项] \u003c配置名称:路径\u003e \u003c本地路径\u003e [参数] [参数] # 网盘到网盘 rclone [功能选项] \u003c配置名称:路径\u003e \u003c配置名称:路径\u003e [参数] [参数] # [参数]为可选项 示例 # 复制到网盘，并显示实时传输进度，设置并行上传数为8 rclone copy -P /home/SunPma GD:/home/SunPma --transfers=8 # 如果需要服务端对服务端的传输可加以下参数（不消耗本地流量） rclone copy 配置名称:网盘路径 配置名称:网盘路径 --drive-server-side-across-configs 功能 命令 说明 rclone copy 复制 rclone move 移动，如果要在移动后删除空源目录，加上 –delete-empty-src-dirs 参数 rclone sync 同步：将源目录同步到目标目录，只更改目标目录 rclone size 查看网盘文件占用大小 rclone delete 删除路径下的文件内容 rclone purge 删除路径及其所有文件内容 rclone mkdir 创建目录 rclone rmdir 删除目录 rclone rmdirs 删除指定环境下的空目录。如果加上 –leave-root 参数，则不会删除根目录 rclone check 检查源和目的地址数据是否匹配 rclone ls 列出指定路径下的所有的文件以及文件大小和路径 rclone lsl 比上面多一个显示上传时间 rclone lsd 列出指定路径下的目录 rclone lsf 列出指定路径下的目录和文件 参数 命令 说明 -n = –dry-run 测试运行，查看Rclon在实际运行中会进行哪些操作 -P = –progress 显示实时传输进度，500mS刷新一次，否则默认1分钟刷新一次 –cache-chunk-size 5M 块的大小，默认5M越大上传越快，占用内存越多，太大可能会导致进程中断 –onedrive-chunk-size 100M 提高OneDrive上传速度适用于G口宽带服务器（默认为320KB） –drive-chunk-size 64M 提高Google Drive上传速度适用于G口宽带服务器（默认为8M） –cache-chunk-total-size SizeSuffix 块可以在本地磁盘上占用的总大小，默认10G –transfers=N 并行文件数，默认为4 –config string 指定配置文件路径，string为配置文件路径 –ignore-errors 跳过错误 –size-only 根据文件大小校验，不校验hash –drive-server-side-across-configs 服务端对服务端传输 日志 有4个级别的日志记录：ERROR NOTICE INFO DEBUG 默认情况下Rclon将生成ERROR NOTICE日志 命令 说明 -q rclone将仅生成ERROR消息 -v rclone将生成ERROR NOTICE INFO 消息 -vv rclone 将生成ERROR NOTICE INFO DEBUG 消息 –log-level LEVEL 标志控制日志级别 输出日志到文件 使用--log-file=FILE选项rclone会将Error Info Debug消息以及标准错误重定向到FILE 这里的FILE是你指定的日志文件路径 过滤 命令 说明 –exclude 排除文件或目录 –include 包含文件或目录 –filter 文件过滤规则，相当于上面两个选项的其它使用方式。包含规则以+开头，排除规则以-开头 文件类型过滤 例如--exclude \"*.bak\" --filter \"- *.bak\"排除所有bak文件 例如--include \"*.{png,jpg}\" --filter \"+ *.{png,jpg}\"包含所有png和jpg文件，排除其他文件 例如--delete-excluded删除排除的文件。需配合过滤参数使用，否则无效 目录过滤 目录过滤需要在目录名称后面加上/否则会被当做文件进行匹配 以/开头只会匹配根目录（指定目录下），否则匹配所目录，这同样适用于文件 --exclude \".git/\"排除所有目录下的.git目录 --exclude \"/.git/\"只排除根目录下的.git目录 --exclude \"{Video,Software}/\"排除所有目录下的Video和Software目录 --exclude \"/{Video,Software}/\"只排除根目录下的Video和Software目录 --include \"/{Video,Software}/**\"仅包含根目录下的Video和Software目录的所有内容 大小过滤 默认大小单位为kBytes但可以使用k M或G后缀 --min-size过滤小于指定大小的文件。比如--min-size 50表示不会传输小于50k的文件。 --max-size过滤大于指定大小的文件。比如--max-size 1G表示不会传输大于1G的文件。 实际使用中发现大小过滤两个选项不能同时使用 过滤规则文件 --filter-from \u003c规则文件\u003e从文件添加包含/排除规则 比如--filter-from filter-file.txt 过滤规则文件示例： - secret*.jpg + *.jpg + *.png + file2.avi - /dir/Trash/** + /dir/** - * 环境变量 rclone中的每个选项都可以通过环境变量设置。环境变量的名称可以通过长选项名称进行转换，删除--前缀，更改-为_大写并添加前缀RCLONE_环境变量的优先级会低于命令行选项，即通过命令行追加相应的选项时会覆盖环境变量设定的值。 比如设置最小上传大小--min-size 50使用环境变量是RCLONE_MIN_SIZE=50当环境变量设置后，在命令行中使用--min-size 100那么此时环境变量的值就会被覆盖 常用环境变量 命令 说明 RCLONE_CONFIG 自定义配置文件路径 RCLONE_CONFIG_PASS 若 rclone 进行了加密设置，把此环境变量设置为密码，可自动解密配置文件 RCLONE_RETRIES 上传失败重试次数，默认 3 次 RCLONE_RETRIES_SLEEP 上传失败重试等待时间，默认禁用，单位s、m、h分别代表秒、分钟、小时 CLONE_TRANSFERS 并行上传文件数 RCLONE_CACHE_CHUNK_SIZE 块的大小，默认5M RCLONE_CACHE_CHUNK_TOTAL_SIZE 块可以在本地磁盘上占用的总大小，默认10G RCLONE_IGNORE_ERRORS=true 跳过错误 转载链接 https://sunpma.com/864.html ","date":"2023-01-04","objectID":"/rclone-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/:0:0","tags":["Rclone","Gdrive"],"title":"Rclone 常用命令参数","uri":"/rclone-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/"},{"categories":["日常"],"content":"Hellow Word !","date":"2022-12-21","objectID":"/hello-word/","tags":["First"],"title":"Hello Word","uri":"/hello-word/"},{"categories":["日常"],"content":"Hello Word ! ","date":"2022-12-21","objectID":"/hello-word/:0:0","tags":["First"],"title":"Hello Word","uri":"/hello-word/"}]